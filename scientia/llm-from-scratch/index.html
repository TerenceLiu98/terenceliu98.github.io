<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://blog.cklau.cc/images/logo.svg" />
<title>üßëüèø‚Äçüíª Train A Language Model From Scratch | ÁâπÂÄ´ËòáÁöÑÊó•ËàáÂ§ú</title>
<meta name="title" content="üßëüèø‚Äçüíª Train A Language Model From Scratch" />
<meta name="description" content="Beginning You may think that the training a language model from scratch can seem like a daunting task, but it is a rewarding journey that deepens your understanding of machine learning and natural language processing. In this guide, we will explore the fundamental steps required to build a language model, from data preparation to model training and evaluation. Whether you&rsquo;re a beginner or an experienced practitioner, this process will provide valuable insights into the inner workings of large language models." />
<meta name="keywords" content="Artificial Intelligence,language model,LLM," />


<meta property="og:title" content="üßëüèø‚Äçüíª Train A Language Model From Scratch" />
<meta property="og:description" content="Beginning You may think that the training a language model from scratch can seem like a daunting task, but it is a rewarding journey that deepens your understanding of machine learning and natural language processing. In this guide, we will explore the fundamental steps required to build a language model, from data preparation to model training and evaluation. Whether you&rsquo;re a beginner or an experienced practitioner, this process will provide valuable insights into the inner workings of large language models." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.cklau.cc/scientia/llm-from-scratch/" /><meta property="article:section" content="scientia" />
<meta property="article:published_time" content="2024-12-27T00:15:00+00:00" />
<meta property="article:modified_time" content="2024-12-27T00:15:00+00:00" />




<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="üßëüèø‚Äçüíª Train A Language Model From Scratch"/>
<meta name="twitter:description" content="Beginning You may think that the training a language model from scratch can seem like a daunting task, but it is a rewarding journey that deepens your understanding of machine learning and natural language processing. In this guide, we will explore the fundamental steps required to build a language model, from data preparation to model training and evaluation. Whether you&rsquo;re a beginner or an experienced practitioner, this process will provide valuable insights into the inner workings of large language models."/>



<meta itemprop="name" content="üßëüèø‚Äçüíª Train A Language Model From Scratch">
<meta itemprop="description" content="Beginning You may think that the training a language model from scratch can seem like a daunting task, but it is a rewarding journey that deepens your understanding of machine learning and natural language processing. In this guide, we will explore the fundamental steps required to build a language model, from data preparation to model training and evaluation. Whether you&rsquo;re a beginner or an experienced practitioner, this process will provide valuable insights into the inner workings of large language models."><meta itemprop="datePublished" content="2024-12-27T00:15:00+00:00" />
<meta itemprop="dateModified" content="2024-12-27T00:15:00+00:00" />
<meta itemprop="wordCount" content="1184">
<meta itemprop="keywords" content="Artificial Intelligence,language model,LLM," />
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: "Noto Serif SC", serif;
    font-weight: 500;
    font-style: normal;
    margin: auto;
    padding: 20px;
    max-width: 980px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #444;
    text-decoration: none;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  main content p a {
    word-wrap: break-word;
    border: none;
    box-shadow: inset 0 -2px #444;
    transition-property: box-shadow;
    transition-duration: .1s;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
    line-height: 2;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 6.5rem;
  }

  ul.blog-posts li time {
    color: #8e8d8d;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }


   


  .bg { background-color: #f0f0f0; }
  .chroma { background-color: #f0f0f0; }
  .chroma .x {  }
  .chroma .err {  }
  .chroma .cl {  }
  .chroma .lnlinks { outline: none; text-decoration: none; color: inherit }
  .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
  .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; }
  .chroma .hl { background-color: #ffffcc }
  .chroma .lnt { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #7f7f7f }
  .chroma .ln { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #7f7f7f }
  .chroma .line { display: flex; }
  .chroma .k { color: #007020; font-weight: bold }
  .chroma .kc { color: #007020; font-weight: bold }
  .chroma .kd { color: #007020; font-weight: bold }
  .chroma .kn { color: #007020; font-weight: bold }
  .chroma .kp { color: #007020 }
  .chroma .kr { color: #007020; font-weight: bold }
  .chroma .kt { color: #902000 }
  .chroma .n {  }
  .chroma .na { color: #4070a0 }
  .chroma .nb { color: #007020 }
  .chroma .bp {  }
  .chroma .nc { color: #0e84b5; font-weight: bold }
  .chroma .no { color: #60add5 }
  .chroma .nd { color: #555555; font-weight: bold }
  .chroma .ni { color: #d55537; font-weight: bold }
  .chroma .ne { color: #007020 }
  .chroma .nf { color: #06287e }
  .chroma .fm {  }
  .chroma .nl { color: #002070; font-weight: bold }
  .chroma .nn { color: #0e84b5; font-weight: bold }
  .chroma .nx {  }
  .chroma .py {  }
  .chroma .nt { color: #062873; font-weight: bold }
  .chroma .nv { color: #bb60d5 }
  .chroma .vc {  }
  .chroma .vg {  }
  .chroma .vi {  }
  .chroma .vm {  }
  .chroma .l {  }
  .chroma .ld {  }
  .chroma .s { color: #4070a0 }
  .chroma .sa { color: #4070a0 }
  .chroma .sb { color: #4070a0 }
  .chroma .sc { color: #4070a0 }
  .chroma .dl { color: #4070a0 }
  .chroma .sd { color: #4070a0; font-style: italic }
  .chroma .s2 { color: #4070a0 }
  .chroma .se { color: #4070a0; font-weight: bold }
  .chroma .sh { color: #4070a0 }
  .chroma .si { color: #70a0d0 }
  .chroma .sx { color: #c65d09 }
  .chroma .sr { color: #235388 }
  .chroma .s1 { color: #4070a0 }
  .chroma .ss { color: #517918 }
  .chroma .m { color: #40a070 }
  .chroma .mb { color: #40a070 }
  .chroma .mf { color: #40a070 }
  .chroma .mh { color: #40a070 }
  .chroma .mi { color: #40a070 }
  .chroma .il { color: #40a070 }
  .chroma .mo { color: #40a070 }
  .chroma .o { color: #666666 }
  .chroma .ow { color: #007020; font-weight: bold }
  .chroma .p {  }
  .chroma .c { color: #60a0b0; font-style: italic }
  .chroma .ch { color: #60a0b0; font-style: italic }
  .chroma .cm { color: #60a0b0; font-style: italic }
  .chroma .c1 { color: #60a0b0; font-style: italic }
  .chroma .cs { color: #60a0b0; background-color: #fff0f0 }
  .chroma .cp { color: #007020 }
  .chroma .cpf { color: #007020 }
  .chroma .g {  }
  .chroma .gd { color: #a00000 }
  .chroma .ge { font-style: italic }
  .chroma .gr { color: #ff0000 }
  .chroma .gh { color: #000080; font-weight: bold }
  .chroma .gi { color: #00a000 }
  .chroma .go { color: #888888 }
  .chroma .gp { color: #c65d09; font-weight: bold }
  .chroma .gs { font-weight: bold }
  .chroma .gu { color: #800080; font-weight: bold }
  .chroma .gt { color: #0044dd }
  .chroma .gl { text-decoration: underline }
  .chroma .w { color: #bbbbbb }


 
.sidenote {
    font-size: 80%;         
    font-weight: normal;
    color: var(--theme-hl1-color);
    position: relative;     
}
 
@media (min-width: 1400px) {
    .sidenote {
        float: right;
        clear: right;            
        text-align: left;

         
            
        top: -3rem;             
        width: 20vw;            
        margin-right: -23vw;     
        margin-top: 1rem;       
    }
}
 
 
@media (max-width: 1400px) {
    .sidenote {
         
        float: right;
        text-align: left;

            
        width: 100%;  
        margin: 1rem 0;
        padding-left: 5%;  
    }
}
 
 
body {
    counter-reset: sidenote-counter;
}
.sidenote-number {
    counter-increment: sidenote-counter;
}
 
.sidenote::before {
    content: "\2020";
    position: relative;
    vertical-align: super;
    font-size: 0.9em;
    font-weight: bold;
}
 
.sidenote-number::after {
    content: "\2020";
    position: relative;
    vertical-align: super;
    font-size: 0.7em;
    font-weight: bold;
    color: var(--theme-body-color);
    display: inline;
    margin-right: 0.2rem;
}
@media (min-width: 1400px) {
     
    .sidenote-number:hover .sidenote {
        background-color: var(--theme-color-light);
    }
}

  
.card-container {
    display: flex;
    flex-direction: column;
    align-items: center;  
    gap: 5px;  
    padding: 5px;
}

.card {
    width: 80%;  
    box-shadow: 0 0px 0px rgba(0,0,0,0.1);  
    display: flex;
    align-items: center;  
    padding: 10px;
    background: white;  
    text-decoration: none;  
    color: inherit;  
}

.card img {
    width: 80px;  
    height: 80px;
    border-radius: 50%;  
    margin-right: 20px;  
}

.card .info h2 {
    margin: 0;
    font-size: 1.2em;  
}

.card .info p {
    margin: 5px 0 0;  
    font-size: 0.9em;
    color: #444;  
}
.card .info span{
    font-size: 0.5em;
    color: #666;
}


.research-card {
  border: 1px solid #ddd;
  padding: 20px;
  margin-bottom: 20px;
  border-radius: 8px;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.research-card h2 {
  margin-top: 0;
}

.research-card .subtitle {
  font-size: 14px;
  color: #555;
}

.research-card .description {
  font-size: 16px;
  margin: 10px 0;
}

.research-card .authors {
  font-size: 14px;
  color: #777;
}

.research-card .buttons {
  margin-top: 10px;
}

.research-card .btn {
  display: inline-block;
  margin-right: 10px;
  padding: 8px 12px;
  font-size: 14px;
  text-decoration: none;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}

.research-card .btn-primary {
  background-color: #007bff;
  color: #fff;
}

.research-card .btn-secondary {
  background-color: #6c757d;
  color: #fff;
}

.research-card .btn-tertiary {
  background-color: #28a745;
  color: #fff;
}

.research-card .btn:hover {
  opacity: 0.9;
}


</style>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500&display=swap" rel="stylesheet">
<script defer data-domain="nova.moe" src="https://possible.knat.network/js/script.js"></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1844674035384472" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="https://blog.cklau.cc/feed.xml" title="ÁâπÂÄ´ËòáÁöÑÊó•ËàáÂ§ú">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/contrib/auto-render.min.js"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true },
                { left: "\\begin{equation}", right: "\\end{equation}", display: true },
                { left: "\\begin{align}", right: "\\end{align}", display: true },
                { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
                { left: "\\begin{gather}", right: "\\end{gather}", display: true },
                { left: "\\begin{CD}", right: "\\end{CD}", display: true },
                { left: "\\[", right: "\\]", display: true }
            ],
            
            throwOnError: false,
            trust: (context) => ['\\htmlId', '\\href'].includes(context.command),
            macros: {
                "\\eqref": "\\href{###1}{(\\text{#1})}",
                "\\ref": "\\href{###1}{\\text{#1}}",
                "\\label": "\\htmlId{#1}{}"
            }
        });
    });
</script>
</head>

<body>
  <header><a href="/" class="title">
  <h2>ÁâπÂÄ´ËòáÁöÑÊó•ËàáÂ§ú</h2>
</a>
<nav><a href="/">Home</a>

<a href="/post">[Blog]</a>

<a href="/scientia">[Scientia]</a>

<a href="/projects">[Projects]</a>

<a href="/links">[Links]</a>

</nav>
</header>
  <main>
<h1>üßëüèø‚Äçüíª Train A Language Model From Scratch</h1>
<p>
  <i>
    <time datetime='2024-12-27' pubdate>
      27 Dec, 2024
    </time>
  </i>
</p>

<content>
  <h2 id="beginning">Beginning</h2>
<p>You may think that the training a language model from scratch can seem like a daunting task, but it is a rewarding journey that deepens your understanding of machine learning and natural language processing. In this guide, we will explore the fundamental steps required to build a language model, from data preparation to model training and evaluation. Whether you&rsquo;re a beginner or an experienced practitioner, this process will provide valuable insights into the inner workings of large language models.</p>
<h2 id="starting-from-the-tasks">Starting from the tasks</h2>
<p>When training a language model, various tasks are employed to help the model learn and generalize effectively. These tasks are tailored to different stages of the training process, such as pretraining, supervised fine-tuning (SFT), and reinforcement learning with human feedback (RLHF). Below are some of the most widely used tasks, along with detailed explanations:</p>
<ul>
<li>
<p><strong>Masked Language Modeling (MLM):</strong><br>
Starting from the MLM, which is widely used in the word embedding training, proposed by Google in 2017 [<a class="hugo-simplecite-cite-hyperlink" href="#bibreference-1" title="J. Devlin, M. Chang, K. Lee, and K. Toutanova, Bert: Pre-training of deep bidirectional transformers for language understanding, In Proc. Proceedings of the 2019 conference of the north american chapter of the association for computational linguistics: Human language technologies, volume 1 (long and short papers), 2019, pp. 4171‚Äì4186. ">1</a>]. In short, it is a pretraining task where certain tokens in the input sequence are randomly masked, and the model is trained to predict these masked tokens based on their surrounding context. This task enables the model to learn bidirectional representations of text, making it effective for understanding the relationships between words in a sentence. For example, in the sentence &ldquo;The [MASK] is blue,&rdquo; the model learns to predict the masked word &ldquo;sky.&rdquo; Models like BERT and RoBERTa heavily rely on MLM for pretraining. The <code>DataCollatorForLanguageModeling</code> in the Hugging Face Transformers library is often used to implement this task, where it handles token masking dynamically during training.</p>
</li>
<li>
<p><strong>Causal Language Modeling (CLM):</strong><br>
CLM, also known as autoregressive modeling, involves predicting the next token in a sequence based on the previous tokens. This task is unidirectional, meaning the model only considers past context when generating the next word. For instance, given the input &ldquo;The cat is,&rdquo; the model predicts the next word, such as &ldquo;sleeping.&rdquo; CLM is the backbone of models like GPT and GPT-2, which are designed for text generation tasks. The <code>DataCollatorForLanguageModeling</code> can be used for CLM, depending on the implementation.</p>
</li>
<li>
<p><strong>Supervised Fine-Tuning (SFT):</strong><br>
SFT is a critical step after pretraining, where the model is fine-tuned on labeled datasets for specific downstream tasks. These tasks can include text classification, summarization, or question answering. For example, in summarization, the model is trained to generate concise summaries of input documents. During SFT, the model learns to adapt its pretrained knowledge to domain-specific requirements. The <code>DataCollatorForSeq2Seq</code> is often used for tasks like summarization, as it handles input-output pairs efficiently.</p>
</li>
<li>
<p><strong>Reinforcement Learning with Human Feedback (RLHF):</strong><br>
RLHF is used to align the model&rsquo;s outputs with human preferences and ethical considerations. This process involves three main steps:</p>
<ol>
<li><strong>Supervised Fine-Tuning:</strong> A base model is fine-tuned on a dataset of human-labeled examples.</li>
<li><strong>Reward Model Training:</strong> A separate reward model is trained to score the quality of the model&rsquo;s outputs based on human feedback.</li>
<li><strong>Policy Optimization:</strong> The language model is further fine-tuned using reinforcement learning, guided by the reward model.<br>
RLHF is particularly useful for tasks like conversational AI, where the model needs to generate responses that are both helpful and aligned with user expectations.</li>
</ol>
</li>
</ul>
<p>By combining these tasks, we can train language models that are not only powerful but also versatile and aligned with human expectations. Each task plays a unique role in shaping the model&rsquo;s capabilities, from understanding context to generating coherent and meaningful text.</p>
<h2 id="what-about-the-data-format">What about the Data Format</h2>
<p>The format of the training data plays a crucial role in determining the effectiveness of the language model. Different formats are used depending on the task and the stage of training, such as pretraining, fine-tuning, or reinforcement learning. Below, we discuss some commonly used data formats, including the Alpaca format and Vicuna&rsquo;s multi-round chat format.</p>
<h3 id="alpaca-format">Alpaca Format</h3>
<p>The Alpaca format is designed for instruction-tuning tasks, where the model is fine-tuned to follow instructions and generate helpful responses. This format typically consists of a JSON structure with fields such as <code>instruction</code>, <code>input</code>, and <code>output</code>. Here&rsquo;s an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;instruction&#34;</span>: <span style="color:#e6db74">&#34;Summarize the following text.&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;input&#34;</span>: <span style="color:#e6db74">&#34;Artificial intelligence is a branch of computer science that aims to create machines that can perform tasks that typically require human intelligence.&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;output&#34;</span>: <span style="color:#e6db74">&#34;Artificial intelligence is a field focused on creating machines capable of human-like intelligence.&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>Instruction:</strong> Specifies the task the model should perform.</li>
<li><strong>Input:</strong> Provides additional context or data required to complete the task. This field can be empty for tasks that don&rsquo;t require extra input.</li>
<li><strong>Output:</strong> Contains the expected response or result for the given instruction and input.</li>
</ul>
<p>This format is widely used in fine-tuning models like Alpaca and other instruction-following models. It ensures that the model learns to handle a variety of tasks in a structured manner.</p>
<h3 id="vicunas-multi-round-chat-format">Vicuna&rsquo;s Multi-Round Chat Format</h3>
<p>Vicuna&rsquo;s multi-round chat format is tailored for conversational AI models, where the goal is to train the model to handle multi-turn dialogues effectively. This format captures the back-and-forth nature of human conversations. An example of this format is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;conversation&#34;</span>: [
</span></span><span style="display:flex;"><span>    {<span style="color:#f92672">&#34;role&#34;</span>: <span style="color:#e6db74">&#34;user&#34;</span>, <span style="color:#f92672">&#34;content&#34;</span>: <span style="color:#e6db74">&#34;What is the capital of France?&#34;</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#f92672">&#34;role&#34;</span>: <span style="color:#e6db74">&#34;assistant&#34;</span>, <span style="color:#f92672">&#34;content&#34;</span>: <span style="color:#e6db74">&#34;The capital of France is Paris.&#34;</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#f92672">&#34;role&#34;</span>: <span style="color:#e6db74">&#34;user&#34;</span>, <span style="color:#f92672">&#34;content&#34;</span>: <span style="color:#e6db74">&#34;Can you tell me more about it?&#34;</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#f92672">&#34;role&#34;</span>: <span style="color:#e6db74">&#34;assistant&#34;</span>, <span style="color:#f92672">&#34;content&#34;</span>: <span style="color:#e6db74">&#34;Paris is known as the City of Light and is famous for its art, culture, and landmarks like the Eiffel Tower.&#34;</span>}
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>Role:</strong> Indicates whether the message is from the <code>user</code> or the <code>assistant</code>.</li>
<li><strong>Content:</strong> Contains the text of the message.</li>
</ul>
<p>This format is particularly useful for fine-tuning models to generate coherent and contextually relevant responses in multi-turn conversations. It helps the model maintain context across multiple exchanges, making it suitable for chatbots and virtual assistants. However, I don&rsquo;t think the format are most important</p>
<p>However, different formats can be leveraged by the <code>process</code> function, which means the format is not the first priority of in the training process, instead, the data itself is. Below is a example for converting vicuna format to alpaca.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">vicuna_to_alpaca</span>(conversation):
</span></span><span style="display:flex;"><span>    user <span style="color:#f92672">=</span> [conv<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;user&#34;</span>, <span style="color:#e6db74">&#34;None&#34;</span>) <span style="color:#66d9ef">for</span> conv <span style="color:#f92672">in</span> conversation]
</span></span><span style="display:flex;"><span>    assistant <span style="color:#f92672">=</span> [conv<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;assistant&#34;</span>, <span style="color:#e6db74">&#34;None&#34;</span>) <span style="color:#66d9ef">for</span> conv <span style="color:#f92672">in</span> conversation]
</span></span><span style="display:flex;"><span>    instruct <span style="color:#f92672">=</span> [conv<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;instruction&#34;</span>, <span style="color:#e6db74">&#34;None&#34;</span>) <span style="color:#66d9ef">for</span> conv <span style="color:#f92672">in</span> conversation]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> instruct, user, assistant
</span></span></code></pre></div><h2 id="data-filtering">Data Filtering</h2>
<p>Although format might be important, data quality is much vital for the training. As the raw corpora are riddled with inconsistencies, artifacts, and ethical pitfalls. Depulication, for instance, goes beyond simple substring matching: advanced methods like MinHash or SimHash identify near-duplicates at scale, while fuzzy hashing detects paraphrased or lightly edited repetitions. Similarly, normalization involves granular steps: Unicode normalization (e.g., converting ‚Äúcaf√©‚Äù and ‚ÄúcafeÃÅ‚Äù to a consistent form), stripping non-linguistic markup (e.g., LaTeX, HTML tags), and handling whitespace irregularities (e.g., replacing multiple spaces or tabs with a single space). Tools like ftfy (‚Äúfixes text for you‚Äù) repair mojibake (garbled text from encoding errors). What&rsquo;s more, corpora can also contains toxicity and bias, to filtering these harmful content requires multi-layered strategies. Model-based methods is now most widely used, like Google&rsquo;s perspective API or Huggingface&rsquo;s detoxify flag can help remove explicit hate speech, but nuanced toxicity (e.g., microaggressions, sarcasm) demands custom fine-tuning.</p>
<p>Different steps has different filtering process. For instance, instruct-tuning process</p>

</content>

<p>
  
  <a href="https://blog.cklau.cc/tags/artificial-intelligence/">#Artificial Intelligence</a>
  
  <a href="https://blog.cklau.cc/tags/language-model/">#language model</a>
  
  <a href="https://blog.cklau.cc/tags/llm/">#LLM</a>
  
</p>

  </main>
  <footer>


<p>
    <span><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">Á≤§ICPÂ§á2022102668Âè∑</a></span>

&copy; 2025 <a href="https://blog.cklau.cc">Junjie LIU</a>
    <a href="https://blog.cklau.cc/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
    <br>
Hosting and images served by <a href="https://cloud.tencent.com/">Tencent Cloud</a> / <a href="https://cloudflare.com/">Cloudflare</a> / <a href="https://webp.se/">WebP Cloud Services</a>
</p>

</footer>

    
</body>

</html>
